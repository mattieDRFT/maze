<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Runner</title>
    <!-- Google Fonts - Inter for clean typography -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base styles for the html and body elements inside the iframe */
        html, body {
            height: 100%; /* Make them fill the full iframe height */
            width: 100%; /* Make them fill the full iframe width */
            margin: 0; /* Remove default margins */
            overflow: hidden; /* Crucial: Prevent scrolling on html/body itself */
            font-family: 'Inter', sans-serif;
            background-color: #000000; /* Black background */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Styling for the main game container */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center; /* Center items horizontally */
            background-color: transparent; /* Transparent background */
            padding: 0; /* Remove padding for a cleaner look */
            border-radius: 0; /* Remove rounded corners */
            box-shadow: none; /* Remove shadows */
            width: 100%; /* Allow container to take full width of iframe */
            height: 100%; /* Allow container to take full height of iframe */
            position: relative;
            z-index: 1;
        }

        /* Styling for the game canvas itself */
        canvas {
            background-color: #FFFF00; /* Glowing yellow for maze paths */
            border: 4px solid #000000; /* Black border to contrast with yellow maze */
            border-radius: 0.5rem; /* Rounded corners for the canvas */
            /* Prevents common mobile browser gestures like scrolling/zooming,
               allowing touch events to be used for game control */
            touch-action: none; /* Keep touch-action on canvas */
            display: block; /* Removes extra space below canvas */
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="mazeCanvas"></canvas>
    </div>

    <script>
        // Get references to DOM elements
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');

        // Mouse and touch state variables
        let mouse = { x: 0, y: 0, isDown: false };
        let touch = { x: 0, y: 0, isDown: false };

        // Maze configuration - A smaller, simpler maze for better mobile fit.
        const maze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
            [1,1,1,0,1,0,1,1,1,0,1,0,1,0,1],
            [1,0,0,0,0,0,1,0,1,0,0,0,1,0,1],
            [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,0,1,1,1,1,1,0,1],
            [1,0,0,0,0,0,1,0,1,0,0,0,1,0,1],
            [1,0,1,1,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,1,0,0,0,1,0,1,0,1,0,1,0,1],
            [1,0,1,0,1,1,1,0,1,0,1,0,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,0,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];


        let cellSize;
        // Ball physics parameters adjusted for the smaller maze (might feel faster with same values)
        let ball = { x: 0, y: 0, radius: 0, vx: 0, vy: 0, speed: 1.0, damping: 0.8 };
        let targetX = 0;
        let targetY = 0;
        let gameStarted = false;
        let gameWon = false;
        let animationFrameId; // Stores the ID from requestAnimationFrame for cancellation

        // Start and End points (in maze grid coordinates for the new maze)
        const startPoint = { row: 1, col: 1 };
        const endPoint = { row: maze.length - 2, col: maze[0].length - 2 }; // Second to last row, second to last column

        /**
         * Draws the red ball at its current calculated position.
         */
        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2); // Draw a circle
            ctx.fillStyle = '#e53e3e'; // Red color for the ball
            ctx.fill();
        }

        /**
         * Initializes or resets the game state.
         * Calculates cell size based on screen, resets ball position, and starts animation.
         */
        function initializeGame() {
            // Stop any ongoing animation frame to prevent multiple game loops
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            const rows = maze.length;
            const cols = maze[0].length;

            // Set canvas drawing buffer resolution to match the window (iframe's internal viewport)
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Calculate cellSize to ensure the entire maze fits within the canvas
            const cellSizeFromWidth = Math.floor(canvas.width / cols);
            const cellSizeFromHeight = Math.floor(canvas.height / rows);
            cellSize = Math.min(cellSizeFromWidth, cellSizeFromHeight);

            // Ensure a minimum practical size for touch, even if calculations suggest smaller.
            // This acts as a floor to prevent elements from becoming minuscule on tiny screens.
            cellSize = Math.max(cellSize, 40); // Maintain a strong minimum cell size (e.g., 40px)

            // Re-calculate canvas dimensions based on the final determined cellSize.
            // This makes sure the canvas's drawing area perfectly matches the maze at its best possible size.
            canvas.width = cols * cellSize;
            canvas.height = rows * cellSize;

            // Initialize ball's position to the center of the start cell
            ball.radius = cellSize * 0.4; // Ball radius is 40% of cell size
            ball.x = startPoint.col * cellSize + cellSize / 2;
            ball.y = startPoint.row * cellSize + cellSize / 2;
            ball.vx = 0; // Reset horizontal velocity
            ball.vy = 0; // Reset vertical velocity

            // Set initial target to current ball position to prevent immediate movement
            targetX = ball.x;
            targetY = ball.y;

            gameStarted = true; // Mark game as started
            gameWon = false;    // Reset win condition
            drawMaze();         // Draw the maze and ball in their initial states
            animate();          // Start the main game animation loop
        }

        /**
         * Draws the maze walls, start point, end point, and the ball on the canvas.
         */
        function drawMaze() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the entire canvas

            // Iterate through the maze array to draw walls
            for (let row = 0; row < maze.length; row++) {
                for (let col = 0; col < maze[row].length; col++) {
                    if (maze[row][col] === 1) { // If cell contains a wall
                        ctx.fillStyle = '#000000'; /* Wall color (black) to contrast with yellow paths */
                        ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize); // Draw wall
                    }
                }
            }

            // Draw start point (glowing yellow fill with black border)
            ctx.fillStyle = '#FFFF00'; // Yellow fill
            ctx.fillRect(startPoint.col * cellSize, startPoint.row * cellSize, cellSize, cellSize);
            ctx.strokeStyle = '#000000'; // Black border
            ctx.lineWidth = 1;
            ctx.strokeRect(startPoint.col * cellSize, startPoint.row * cellSize, cellSize, cellSize);
            // Draw a small black circle in the start cell
            ctx.beginPath();
            ctx.arc(startPoint.col * cellSize + cellSize / 2, startPoint.row * cellSize + cellSize / 2, ball.radius / 2, 0, Math.PI * 2);
            ctx.fillStyle = '#000000'; // Black circle
            ctx.fill();

            // Draw end point (glowing yellow fill with black border)
            ctx.fillStyle = '#FFFF00'; // Yellow fill
            ctx.fillRect(endPoint.col * cellSize, endPoint.row * cellSize, cellSize, cellSize);
            ctx.strokeStyle = '#000000'; // Black border
            ctx.lineWidth = 1;
            ctx.strokeRect(endPoint.col * cellSize, endPoint.row * cellSize, cellSize, cellSize);
            // Draw a small black cross in the end cell
            ctx.strokeStyle = '#000000'; // Black cross
            ctx.lineWidth = 2; // Slightly thicker cross for visibility
            ctx.beginPath();
            ctx.moveTo(endPoint.col * cellSize + cellSize * 0.2, endPoint.row * cellSize + cellSize * 0.8);
            ctx.lineTo(endPoint.col * cellSize + cellSize * 0.8, endPoint.row * cellSize + cellSize * 0.2);
            ctx.moveTo(endPoint.col * cellSize + cellSize * 0.2, endPoint.row * cellSize + cellSize * 0.2);
            ctx.lineTo(endPoint.col * cellSize + cellSize * 0.8, endPoint.row * cellSize + cellSize * 0.8);
            ctx.stroke();

            drawBall(); // Draw the ball last, so it appears on top of the maze
        }

        /**
         * Checks if a specific point (e.g., part of the ball) is inside a maze wall.
         * @param {number} x - X coordinate of the point to check.
         * @param {number} y - Y coordinate of the point to check.
         * @returns {boolean} True if the point is within a wall cell, false otherwise.
         */
        function isWallAt(x, y) {
            // Treat points outside canvas boundaries as walls
            if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
                return true;
            }
            const col = Math.floor(x / cellSize); // Get column index
            const row = Math.floor(y / cellSize); // Get row index
            // Check if the corresponding cell in the maze array is a wall (value 1)
            return maze[row] && maze[row][col] === 1;
        }

        /**
         * The main game animation loop.
         * Updates the ball's position based on physics and input, handles collisions,
         * redraws the game, and checks for win conditions.
         */
        function animate() {
            if (gameWon) {
                cancelAnimationFrame(animationFrameId); // Stop the animation if game is won
                return;
            }

            // Calculate the vector from the ball's current position to the target position
            const dx_target = targetX - ball.x;
            const dy_target = targetY - ball.y;
            const distance_to_target = Math.sqrt(dx_target * dx_target + dy_target * dy_target);

            // Apply force (acceleration) towards the target if the pointer is down
            // and the ball is not extremely close to the target (to prevent jitter)
            if (distance_to_target > 2 && (mouse.isDown || touch.isDown)) {
                ball.vx += (dx_target / distance_to_target) * ball.speed;
                ball.vy += (dy_target / distance_to_target) * ball.speed;
            }

            // Apply damping (friction) to gradually slow down the ball
            ball.vx *= ball.damping;
            ball.vy *= ball.damping;

            // Limit the maximum speed of the ball
            const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            const maxSpeed = cellSize * 0.8; /* Adjusted max speed for new scale */
            if (currentSpeed > maxSpeed) {
                ball.vx = (ball.vx / currentSpeed) * maxSpeed;
                ball.vy = (ball.vy / currentSpeed) * maxSpeed;
            }

            let newBallX = ball.x + ball.vx; // Predicted next X position
            let newBallY = ball.y + ball.vy; // Predicted next Y position

            let collidedX = false;
            let collidedY = false;

            // Collision detection and response for horizontal (X-axis) movement
            // Check multiple points around the ball's circumference at its predicted new X position
            const checkPointsX = [
                { x: newBallX - ball.radius, y: ball.y + 1 },    // Left, slightly below center
                { x: newBallX + ball.radius, y: ball.y + 1 },   // Right, slightly below center
                { x: newBallX - ball.radius, y: ball.y - 1 }, // Left, slightly above center
                { x: newBallX + ball.radius, y: ball.y - 1 },// Right, slightly above center
                { x: newBallX - ball.radius, y: ball.y },         // Left center
                { x: newBallX + ball.radius, y: ball.y }         // Right center
            ];
            for (const p of checkPointsX) {
                if (isWallAt(p.x, p.y)) {
                    collidedX = true;
                    break; // Found a collision, no need to check further points for X
                }
            }

            if (collidedX) {
                ball.vx = 0; // Stop horizontal movement immediately
                // Adjust ball's X position to "snap" it out of the wall, preventing sticking
                const currentCellCol = Math.floor(ball.x / cellSize);
                if (newBallX > ball.x) { // Moving right, hit wall on right
                    ball.x = currentCellCol * cellSize + cellSize - ball.radius - 1;
                } else { // Moving left, hit wall on left
                    ball.x = currentCellCol * cellSize + ball.radius + 1;
                }
            } else {
                ball.x = newBallX; // If no collision, update ball's X position
            }

            // Collision detection and response for vertical (Y-axis) movement
            // Check multiple points around the ball's circumference at its predicted new Y position
            const checkPointsY = [
                { x: ball.x + 1, y: newBallY - ball.radius },    // Top, slightly right of center
                { x: ball.x + 1, y: newBallY + ball.radius },   // Bottom, slightly right of center
                { x: ball.x - 1, y: newBallY - ball.radius }, // Top, slightly left of center
                { x: ball.x - 1, y: newBallY + ball.radius },// Bottom, slightly left of center
                { x: ball.x, y: newBallY - ball.radius },             // Top center
                { x: ball.x, y: newBallY + ball.radius }           // Bottom center
            ];
            for (const p of checkPointsY) {
                if (isWallAt(p.x, p.y)) {
                    collidedY = true;
                    break; // Found a collision, no need to check further points for Y
                }
            }

            if (collidedY) {
                ball.vy = 0; // Stop vertical movement immediately
                // Adjust ball's Y position to "snap" it out of the wall
                const currentCellRow = Math.floor(ball.y / cellSize);
                if (newBallY > ball.y) { // Moving down, hit wall on bottom
                    ball.y = currentCellRow * cellSize + cellSize - ball.radius - 1;
                } else { // Moving up, hit wall on top
                    ball.y = currentCellRow * cellSize + ball.radius + 1;
                }
            } else {
                ball.y = newBallY; // If no collision, update ball's Y position
            }

            // Clamp ball position within canvas boundaries to ensure it never leaves the play area
            ball.x = Math.max(ball.radius, Math.min(ball.x, canvas.width - ball.radius));
            ball.y = Math.max(ball.radius, Math.min(ball.y, canvas.height - ball.radius));

            drawMaze();          // Redraw the entire game state with updated ball position
            checkWinCondition(); // Check if the ball has reached the end point

            // Request the next animation frame, creating a continuous loop
            animationFrameId = requestAnimationFrame(animate);
        }

        /**
         * Sets the target coordinates for the ball based on the user's mouse or touch input.
         * @param {number} clientX - The X coordinate of the input event relative to the viewport.
         * @param {number} clientY - The Y coordinate of the input event relative to the viewport.
         */
        function setTargetPosition(clientX, clientY) {
            if (gameWon) return; // Ignore input if the game is already won

            // Get the canvas's size and position relative to the viewport
            const rect = canvas.getBoundingClientRect();
            // Calculate target coordinates relative to the canvas
            targetX = clientX - rect.left;
            targetY = clientY - rect.top;

            // Clamp target coordinates to stay within canvas bounds
            targetX = Math.max(0, Math.min(targetX, canvas.width));
            targetY = Math.max(0, Math.min(targetY, canvas.height));
        }

        /**
         * Checks if the ball has reached the end point of the maze.
         */
        function checkWinCondition() {
            // Get the grid cell coordinates of the ball
            const ballGridCol = Math.floor(ball.x / cellSize);
            const ballGridRow = Math.floor(ball.y / cellSize);

            // Check if ball is in the same grid cell as the end point and game is not already won
            if (ballGridCol === endPoint.col && ballGridRow === endPoint.row && !gameWon) {
                gameWon = true; // Set game won state
                ctx.fillStyle = 'rgba(72, 187, 120, 0.5)'; // Apply a semi-transparent green overlay for visual feedback
                ctx.fillRect(0, 0, canvas.width, canvas.height); // Draw the overlay
                cancelAnimationFrame(animationFrameId); // Stop the animation loop as the game is over
            }
        }

        // --- Event Listeners for Mouse and Touch Interactions ---

        // Dummy touchstart listener for iOS iframe compatibility
        // This is a common workaround for iOS not properly activating touch events in iframes.
        document.addEventListener('touchstart', () => { /* no-op */ }, { passive: false });

        // Global touchmove listener to explicitly prevent default scrolling behaviour across the entire iframe content.
        // This is crucial for preventing iOS from interpreting game touches as page scrolls.
        window.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive: false });

        // Mouse events (for desktop interaction)
        canvas.addEventListener('mousedown', (e) => {
            mouse.isDown = true;
            setTargetPosition(e.clientX, e.clientY);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (mouse.isDown && gameStarted && !gameWon) {
                setTargetPosition(e.clientX, e.clientY);
            }
        });

        canvas.addEventListener('mouseup', () => {
            mouse.isDown = false;
        });

        canvas.addEventListener('mouseleave', () => {
            mouse.isDown = false;
        });

        // Touch events (for mobile interaction)
        // `passive: false` is crucial here to allow `e.preventDefault()` to stop default browser behaviors (like scrolling)
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent default browser touch actions for canvas touches
            touch.isDown = true;
            const touch = e.touches[0]; // Get the first touch point
            setTargetPosition(touch.clientX, touch.clientY);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent default browser touch actions for canvas touches
            if (touch.isDown && gameStarted && !gameWon) {
                const touch = e.touches[0]; // Get the first touch point
                setTargetPosition(touch.clientX, touch.clientY);
            }
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            touch.isDown = false;
        });

        canvas.addEventListener('touchcancel', () => {
            touch.isDown = false;
        });

        // Handle window resize to ensure the canvas scales correctly on different screen sizes
        window.addEventListener('resize', initializeGame);

        // Initial game setup when the entire window content (including images, etc.) has loaded
        window.onload = initializeGame;
    </script>
</body>
</html>
