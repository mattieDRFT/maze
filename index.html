<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Follow THe Yellow Brick Road (Physics)</title>
    <!-- Tailwind CSS for basic styling and responsiveness utilities -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS for the game, overriding some Tailwind defaults for specific elements */
        body {
            background-color: black; /* Solid black background as requested */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full viewport height */
            margin: 0;
            overflow: hidden; /* Prevent scrolling if canvas overflows slightly */
            font-family: 'Inter', sans-serif; /* Consistent font */
            color: white; /* Default text color */
            flex-direction: column; /* Arrange title and canvas vertically */
        }
        canvas {
            background-color: black; /* The background of the maze paths themselves */
            border: 2px solid yellow; /* A clear yellow border around the maze canvas */
            display: block; /* Remove extra space below canvas */
            margin-top: 20px; /* Space between title and canvas */
            box-shadow: 0 0 25px rgba(255, 255, 0, 0.9); /* Stronger yellow glow effect for aesthetic */
            border-radius: 15px; /* Slightly more rounded corners for the canvas */
        }
        /* Styling for the game message box (win message) */
        .message-box {
            background-color: rgba(30, 30, 30, 0.95); /* Semi-transparent dark background */
            color: yellow; /* Yellow text for the message */
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(255, 255, 0, 2.8); /* Matching glow effect */
            text-align: center;
            position: absolute; /* Position over the canvas */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Center horizontally and vertically */
            display: none; /* Hidden by default, shown on game end */
            z-index: 100; /* Ensure it's on top of other elements */
            min-width: 350px;
            max-width: 90%;
            border: 1px solid yellow; /* Add a subtle border */
        }
        .message-box p {
            font-size: 2rem; /* Larger font for message text */
            font-weight: bold;
            margin-bottom: 25px;
            text-shadow: 0 0 5px yellow; /* Text glow */
        }
        .message-box button {
            background-color: yellow;
            color: black;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.2rem;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease; /* Smooth hover effects */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); /* Button shadow */
        }
        .message-box button:hover {
            background-color: #ffd700; /* Slightly darker yellow on hover */
            transform: translateY(-3px) scale(1.02); /* Slight lift and scale effect */
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
        }
        .instructions {
            margin-top: 15px;
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- Game Title -->
    <h1 class="text-5xl font-extrabold text-yellow-400 drop-shadow-lg text-center tracking-wide">Gema's High Difficulty Maze</h1>
    <p class="instructions"></p>

    <!-- Canvas where the maze game will be drawn -->
    <canvas id="mazeCanvas"></canvas>

    <!-- Message box for win/lose messages -->
    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button id="restartButton">Play Again</button>
    </div>

    <script>
        // Get references to the canvas and message box elements
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');

        // --- Game Configuration Constants ---
        const CANVAS_WIDTH = 800; // Width of the maze canvas in pixels
        const CANVAS_HEIGHT = 600; // Height of the maze canvas in pixels
        const CELL_SIZE = 15; // Smaller cell size for higher difficulty and more intricate maze
        const BALL_RADIUS = 6; // Slightly larger ball relative to new cell size
        
        // Physics constants
        const MOUSE_FORCE_FACTOR = 0.08; // How strongly the mouse attracts the ball
        const DAMPING_FACTOR = 0.93;     // Simulates friction, reduces velocity over time
        const MAX_VELOCITY = 8;          // Cap the ball's speed

        // Calculate the number of columns and rows based on canvas size and cell size
        const MAZE_COLS = Math.floor(CANVAS_WIDTH / CELL_SIZE); 
        const MAZE_ROWS = Math.floor(CANVAS_HEIGHT / CELL_SIZE); 

        // Set the actual canvas dimensions
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // --- Game State Variables ---
        let maze; // 2D array representing the maze grid (0 = path, 1 = wall)
        let ballX, ballY; // Ball's current position (center coordinates)
        let ballVelX, ballVelY; // Ball's current velocity
        let mouseX, mouseY; // Current mouse position relative to the canvas
        let isGameActive = false; // Flag to control if the game loop is running

        // Define the start and end cell coordinates for the maze
        // Start is top-left, End is bottom-right
        const START_CELL_COL = 0;
        const START_CELL_ROW = 0;
        const END_CELL_COL = MAZE_COLS - 1;
        const END_CELL_ROW = MAZE_ROWS - 1;

        // --- Maze Generation (Recursive Backtracking Algorithm) ---
        // This algorithm ensures a single, solvable path through the maze, creating high difficulty.
        function generateMaze() {
            // Initialize the entire maze grid with walls (1)
            maze = Array(MAZE_ROWS).fill(null).map(() => Array(MAZE_COLS).fill(1));
            // Keep track of visited cells during maze generation
            const visited = Array(MAZE_ROWS).fill(null).map(() => Array(MAZE_COLS).fill(false));

            const stack = []; // Stack for backtracking
            let currentRow = START_CELL_ROW;
            let currentCol = START_CELL_COL;

            // Start carving a path from the initial cell
            maze[currentRow][currentCol] = 0; // Mark the starting cell as a path
            visited[currentRow][currentCol] = true; // Mark as visited
            stack.push({ r: currentRow, c: currentCol }); // Add to stack

            // Loop while there are cells to visit on the stack
            while (stack.length > 0) {
                let { r, c } = stack[stack.length - 1]; // Get the current cell (top of stack) without removing it

                const unvisitedNeighbors = [];
                // Define possible directions to move (right, left, down, up)
                // We check neighbors two steps away to ensure walls in between
                const directions = [
                    { dr: 0, dc: 1 },  // Right
                    { dr: 0, dc: -1 }, // Left
                    { dr: 1, dc: 0 },  // Down
                    { dr: -1, dc: 0 }  // Up
                ];

                // Find unvisited neighbors that are two cells away
                for (const dir of directions) {
                    const nextR = r + dir.dr * 2;
                    const nextC = c + dir.dc * 2;

                    // Check if the next cell is within bounds and not yet visited
                    if (nextR >= 0 && nextR < MAZE_ROWS && nextC >= 0 && nextC < MAZE_COLS && !visited[nextR][nextC]) {
                        unvisitedNeighbors.push({ r: nextR, c: nextC, dir: dir });
                    }
                }

                if (unvisitedNeighbors.length > 0) {
                    // If there are unvisited neighbors, pick one randomly
                    const { r: nextR, c: nextC, dir } = unvisitedNeighbors[Math.floor(Math.random() * unvisitedNeighbors.length)];

                    // Carve a path through the wall between the current cell and the chosen neighbor
                    maze[r + dir.dr][c + dir.dc] = 0; // The cell directly between them becomes a path
                    maze[nextR][nextC] = 0;           // The neighbor cell itself becomes a path

                    visited[nextR][nextC] = true; // Mark the neighbor as visited
                    stack.push({ r: nextR, c: nextC }); // Push the neighbor onto the stack to explore from there
                } else {
                    stack.pop(); // If no unvisited neighbors, backtrack by popping from the stack
                }
            }

            // Explicitly ensure the start and end cells are paths, in case the algorithm didn't connect them perfectly
            maze[START_CELL_ROW][START_CELL_COL] = 0;
            maze[END_CELL_ROW][END_CELL_COL] = 0;
        }

        // --- Drawing Functions ---
        // Draws the maze on the canvas
        function drawMaze() {
            for (let r = 0; r < MAZE_ROWS; r++) {
                for (let c = 0; c < MAZE_COLS; c++) {
                    if (maze[r][c] === 1) { // If the cell is a wall
                        ctx.fillStyle = 'yellow'; // Draw it in yellow
                        ctx.fillRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    } else { // If the cell is a path
                        ctx.fillStyle = 'black'; // Draw it in black (background)
                        ctx.fillRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
        }

        // Draws the red ball at its current position
        function drawBall() {
            ctx.beginPath(); // Start a new drawing path
            ctx.arc(ballX, ballY, BALL_RADIUS, 0, Math.PI * 2); // Draw a circle
            ctx.fillStyle = 'red'; // Set ball color to red
            ctx.fill(); // Fill the circle
            ctx.closePath(); // Close a path
        }

        // Draws the blue 'X' at the maze's finish line
        function drawFinishX() {
            // Calculate the pixel center of the end cell
            const endX = END_CELL_COL * CELL_SIZE + CELL_SIZE / 2;
            const endY = END_CELL_ROW * CELL_SIZE + CELL_SIZE / 2;

            ctx.strokeStyle = 'blue'; // Set 'X' color to blue for good contrast
            ctx.lineWidth = 4; // Make the 'X' lines thicker
            ctx.lineCap = 'round'; // Rounded ends for the lines

            // Draw the first line of the 'X'
            ctx.beginPath();
            ctx.moveTo(endX - CELL_SIZE / 2.5, endY - CELL_SIZE / 2.5);
            ctx.lineTo(endX + CELL_SIZE / 2.5, endY + CELL_SIZE / 2.5);
            ctx.stroke(); // Render the line

            // Draw the second line of the 'X'
            ctx.beginPath();
            ctx.moveTo(endX + CELL_SIZE / 2.5, endY - CELL_SIZE / 2.5);
            ctx.lineTo(endX - CELL_SIZE / 2.5, endY + CELL_SIZE / 2.5);
            ctx.stroke(); // Render the line
            ctx.closePath(); // Close the path
        }

        // --- Collision Detection ---
        // Checks if a given pixel coordinate (px, py) is within a wall cell
        function isWallAt(px, py) {
            // If the point is outside the canvas, treat it as a wall to keep the ball within bounds
            if (px < 0 || px >= CANVAS_WIDTH || py < 0 || py >= CANVAS_HEIGHT) {
                return true; 
            }
            // Convert pixel coordinates to grid cell coordinates
            const col = Math.floor(px / CELL_SIZE);
            const row = Math.floor(py / CELL_SIZE);
            
            // Safety check for array bounds (should not be an issue if px/py are clamped within canvas)
            if (row < 0 || row >= MAZE_ROWS || col < 0 || col >= MAZE_COLS) {
                return true; 
            }
            // Return true if the cell at these coordinates is a wall (value 1)
            return maze[row][col] === 1; 
        }

        // Checks if the entire ball (given its center newX, newY, and BALL_RADIUS) collides with any wall.
        // This is crucial for high difficulty, as any part of the ball touching a wall prevents movement.
        function checkBallCollision(newX, newY) {
            // Define points around the ball's circumference to check for collisions.
            // More points mean more accurate collision, but slightly more computation.
            // We use 8 points (every 45 degrees) for good accuracy.
            const pointsToCheck = [];
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI) / 4; // 0, 45, 90, ..., 315 degrees
                pointsToCheck.push({
                    x: newX + BALL_RADIUS * Math.cos(angle),
                    y: newY + BALL_RADIUS * Math.sin(angle)
                });
            }

            // Also check the center of the ball
            pointsToCheck.push({ x: newX, y: newY });

            // Iterate through these points and check if any of them are inside a wall
            for (const p of pointsToCheck) {
                if (isWallAt(p.x, p.y)) {
                    return true; // Collision detected if any point is in a wall
                }
            }
            return false; // No collision if all points are clear
        }


        // --- Game Loop and Logic ---
        function update() {
            // Only update if the game is active (not won)
            if (!isGameActive) {
                return;
            }

            // Calculate force/attraction towards mouse
            const dx = mouseX - ballX;
            const dy = mouseY - ballY;

            // Apply force to velocity, capped by MAX_VELOCITY
            ballVelX += dx * MOUSE_FORCE_FACTOR;
            ballVelY += dy * MOUSE_FORCE_FACTOR;

            // Apply damping (friction)
            ballVelX *= DAMPING_FACTOR;
            ballVelY *= DAMPING_FACTOR;

            // Cap the velocity
            const currentSpeed = Math.sqrt(ballVelX * ballVelX + ballVelY * ballVelY);
            if (currentSpeed > MAX_VELOCITY) {
                ballVelX = (ballVelX / currentSpeed) * MAX_VELOCITY;
                ballVelY = (ballVelY / currentSpeed) * MAX_VELOCITY;
            }

            // Calculate proposed new position
            let newBallX = ballX + ballVelX;
            let newBallY = ballY + ballVelY;

            // Clamp new proposed position to canvas boundaries before collision check
            newBallX = Math.max(BALL_RADIUS, Math.min(newBallX, CANVAS_WIDTH - BALL_RADIUS));
            newBallY = Math.max(BALL_RADIUS, Math.min(newBallY, CANVAS_HEIGHT - BALL_RADIUS));
            
            // Collision detection and response
            if (checkBallCollision(newBallX, ballY)) { // Check X movement collision
                ballVelX = 0; // Stop horizontal movement
                newBallX = ballX; // Revert X position
            }
            if (checkBallCollision(ballX, newBallY)) { // Check Y movement collision
                ballVelY = 0; // Stop vertical movement
                newBallY = ballY; // Revert Y position
            }

            // Check combined movement after individual checks
            if (checkBallCollision(newBallX, newBallY)) {
                // If collision still exists, then it's a corner or complex collision.
                // Revert to original position and stop all movement.
                ballVelX = 0;
                ballVelY = 0;
                newBallX = ballX;
                newBallY = ballY;
            }

            // Update ball's actual position
            ballX = newBallX;
            ballY = newBallY;

            // Check if the ball has reached the end of the maze
            // Calculate the pixel center of the end cell
            const endPixelX = END_CELL_COL * CELL_SIZE + CELL_SIZE / 2;
            const endPixelY = END_CELL_ROW * CELL_SIZE + CELL_SIZE / 2;
            
            // Calculate the distance between the ball's center and the end cell's center
            const distanceToEnd = Math.sqrt(Math.pow(ballX - endPixelX, 2) + Math.pow(ballY - endPixelY, 2));

            // If the ball is within a certain threshold distance to the end point
            if (distanceToEnd < BALL_RADIUS + CELL_SIZE / 4) { // Small buffer for easier detection
                isGameActive = false; // Stop the game
                showMessageBox("Congratulations! You've solved the maze!"); // Display win message
            }

            draw(); // Redraw all game elements for the next frame
            requestAnimationFrame(update); // Request the next animation frame, creating the game loop
        }

        // Main draw function: clears canvas and redraws all elements
        function draw() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); // Clear the entire canvas
            drawMaze(); // Draw the maze walls and paths
            drawFinishX(); // Draw the 'X' at the end
            drawBall(); // Draw the red ball
        }

        // --- Game Initialization ---
        function initGame() {
            hideMessageBox(); // Hide any existing message box
            generateMaze(); // Generate a new maze
            
            // Set the ball's initial position to the center of the start cell
            ballX = START_CELL_COL * CELL_SIZE + CELL_SIZE / 2;
            ballY = START_CELL_ROW * CELL_SIZE + CELL_SIZE / 2;
            
            // Initialize ball velocity to zero
            ballVelX = 0;
            ballVelY = 0;

            // Set the initial mouse position to match the ball's position
            mouseX = ballX; 
            mouseY = ballY;

            isGameActive = true; // Set game state to active
            requestAnimationFrame(update); // Start the game loop
        }

        // --- Event Listeners ---
        // Listen for mouse movement over the canvas
        canvas.addEventListener('mousemove', (e) => {
            // Get the bounding rectangle of the canvas to calculate mouse position relative to it
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left; // Mouse X coordinate relative to canvas
            mouseY = e.clientY - rect.top;  // Mouse Y coordinate relative to canvas
        });

        // --- Message Box Control Functions ---
        // Displays a message in the message box
        function showMessageBox(message) {
            messageText.textContent = message;
            messageBox.style.display = 'block'; // Make the message box visible
        }

        // Hides the message box
        function hideMessageBox() {
            messageBox.style.display = 'none'; // Make the message box hidden
        }

        // Event listener for the restart button inside the message box
        restartButton.addEventListener('click', () => {
            initGame(); // Re-initialize the game when the button is clicked
        });

        // Start the game automatically when the entire window content has loaded
        window.onload = function() {
            initGame();
        };
    </script>
</body>
</html>
