<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Runner</title>
    <!-- Google Fonts - Inter for clean typography -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base styles for the body to center the game and provide a dark background */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background color */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Full viewport height */
            margin: 0; /* Remove default body margin */
            overflow: hidden; /* Prevent body scrolling, important for touch interactions */
        }

        /* Styling for the main game container */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center; /* Center items horizontally */
            background-color: #2d3748; /* Slightly lighter dark grey */
            padding: 1.5rem; /* Inner padding */
            border-radius: 1rem; /* Rounded corners */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5); /* Deep, soft shadow */
            max-width: 90%; /* Max width for responsiveness on larger screens */
            width: fit-content; /* Adjust width to content */
        }

        /* Styling for the game canvas itself */
        canvas {
            background-color: #edf2f7; /* Light background for maze paths */
            border: 4px solid #4a5568; /* Dark border around the maze */
            border-radius: 0.5rem; /* Rounded corners for the canvas */
            /* Prevents common mobile browser gestures like scrolling/zooming,
               allowing touch events to be used for game control */
            touch-action: none;
            display: block; /* Removes extra space below canvas */
            max-width: 100%; /* Ensures canvas scales down on small screens */
            height: auto; /* Maintains aspect ratio when scaling */
        }

        /* Styling for the message box that displays game status */
        .message-box {
            background-color: #4a5568; /* Dark grey background */
            color: #e2e8f0; /* Light text color */
            padding: 0.75rem 1.25rem; /* Padding inside the box */
            border-radius: 0.5rem; /* Rounded corners */
            margin-top: 1.25rem; /* Space above the box */
            font-size: 1.125rem; /* Larger font size */
            text-align: center; /* Center text */
            min-width: 250px; /* Minimum width */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); /* Subtle shadow */
        }

        /* Styling for the reset button */
        .btn-reset {
            background-color: #4299e1; /* Blue background */
            color: white; /* White text */
            padding: 0.75rem 1.5rem; /* Padding */
            border-radius: 0.5rem; /* Rounded corners */
            font-size: 1rem; /* Font size */
            font-weight: bold; /* Bold text */
            margin-top: 1rem; /* Space above button */
            cursor: pointer; /* Pointer cursor on hover */
            border: none; /* No border */
            transition: background-color 0.3s ease, transform 0.2s ease; /* Smooth transitions */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3); /* Button shadow */
        }
        /* Hover effect for the reset button */
        .btn-reset:hover {
            background-color: #3182ce; /* Darker blue on hover */
            transform: translateY(-2px); /* Slight lift effect */
        }
        /* Active (click) effect for the reset button */
        .btn-reset:active {
            transform: translateY(0); /* Return to original position */
        }

        /* Styling for the debug information display */
        #debugInfo {
            margin-top: 0.5rem; /* Space above */
            font-size: 0.8rem; /* Smaller font size */
            background-color: #3b4457; /* Darker background */
            padding: 0.5rem; /* Padding */
            border-radius: 0.5rem; /* Rounded corners */
            color: #cbd5e0; /* Light grey text */
            text-align: center; /* Center text */
            min-width: 250px; /* Minimum width */
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="mazeCanvas"></canvas>
        <div id="messageBox" class="message-box">Move the red ball to the green exit!</div>
        <!-- Debug info display to show touch/mouse state and ball/target positions -->
        <div id="debugInfo">Debug: Mouse Down: false, Touch Down: false</div>
        <button id="resetButton" class="btn-reset">Reset Maze</button>
    </div>

    <script>
        // Get references to DOM elements
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const messageBox = document.getElementById('messageBox');
        const resetButton = document.getElementById('resetButton');
        const debugInfo = document.getElementById('debugInfo');

        // Mouse and touch state variables, declared globally for accessibility by event listeners
        let mouse = { x: 0, y: 0, isDown: false };
        let touch = { x: 0, y: 0, isDown: false };

        // Maze configuration - 1 for wall, 0 for path. This map is unchanged as per your request.
        const maze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1,1,1,1,0,1],
            [1,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,1,0,1],
            [1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,1,1,0,1,0,1],
            [1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,1,0,1],
            [1,0,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,1,0,1,0,1,0,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1],
            [1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1],
            [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
            [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1],
            [1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        let cellSize;
        // Ball physics parameters (tuned for responsiveness on mobile)
        // 'speed' controls acceleration, 'damping' controls how quickly it slows down
        let ball = { x: 0, y: 0, radius: 0, vx: 0, vy: 0, speed: 0.5, damping: 0.9 };
        let targetX = 0;
        let targetY = 0;
        let gameStarted = false;
        let gameWon = false;
        let animationFrameId; // Stores the ID from requestAnimationFrame for cancellation

        // Start and End points (in maze grid coordinates)
        const startPoint = { row: 1, col: 1 };
        const endPoint = { row: maze.length - 2, col: maze[0].length - 2 }; // Second to last row, second to last column

        /**
         * Updates the debug information displayed on the page.
         * Shows mouse/touch status, and current ball/target positions.
         */
        function updateDebugInfo() {
            debugInfo.textContent = `Debug: Mouse Down: ${mouse.isDown}, Touch Down: ${touch.isDown}, ` +
                                   `Ball X: ${ball.x.toFixed(1)}, Y: ${ball.y.toFixed(1)}, ` +
                                   `Target X: ${targetX.toFixed(1)}, Y: ${targetY.toFixed(1)}`;
        }

        /**
         * Initializes or resets the game state.
         * Calculates cell size based on screen, resets ball position, and starts animation.
         */
        function initializeGame() {
            // Stop any ongoing animation frame to prevent multiple game loops
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            // Determine maximum canvas dimensions based on window size for responsiveness
            const maxCanvasWidth = window.innerWidth * 0.9; // Use up to 90% of window width
            const maxCanvasHeight = window.innerHeight * 0.8; // Use up to 80% of window height

            const rows = maze.length;
            const cols = maze[0].length;

            // Calculate the ideal cell size to fit the maze within the max dimensions
            const tempCellSizeWidth = Math.floor(maxCanvasWidth / cols);
            const tempCellSizeHeight = Math.floor(maxCanvasHeight / rows);
            // Cap cell size to ensure paths remain navigable on smaller screens (e.g., mobile)
            cellSize = Math.min(tempCellSizeWidth, tempCellSizeHeight, 18);

            // Set canvas dimensions based on calculated cell size
            canvas.width = cols * cellSize;
            canvas.height = rows * cellSize;

            // Initialize ball's position to the center of the start cell
            ball.radius = cellSize * 0.4; // Ball radius is 40% of cell size
            ball.x = startPoint.col * cellSize + cellSize / 2;
            ball.y = startPoint.row * cellSize + cellSize / 2;
            ball.vx = 0; // Reset horizontal velocity
            ball.vy = 0; // Reset vertical velocity

            // Set initial target to current ball position to prevent immediate movement
            targetX = ball.x;
            targetY = ball.y;

            gameStarted = true; // Mark game as started
            gameWon = false;    // Reset win condition
            messageBox.textContent = "Navigate the red ball to the green exit! Good luck!"; // Initial game message
            updateDebugInfo();  // Update debug information
            drawMaze();         // Draw the maze and ball in their initial states
            animate();          // Start the main game animation loop
        }

        /**
         * Draws the maze walls, start point, end point, and the ball on the canvas.
         */
        function drawMaze() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the entire canvas

            // Iterate through the maze array to draw walls
            for (let row = 0; row < maze.length; row++) {
                for (let col = 0; col < maze[row].length; col++) {
                    if (maze[row][col] === 1) { // If cell contains a wall
                        ctx.fillStyle = '#4a5568'; // Wall color (dark grey)
                        ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize); // Draw wall
                    }
                }
            }

            // Draw start point (light blue square)
            ctx.fillStyle = '#63b3ed';
            ctx.fillRect(startPoint.col * cellSize, startPoint.row * cellSize, cellSize, cellSize);
            // Draw a small white circle within the start cell to indicate ball's starting spot
            ctx.beginPath();
            ctx.arc(startPoint.col * cellSize + cellSize / 2, startPoint.row * cellSize + cellSize / 2, ball.radius / 2, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.fill();

            // Draw end point (green square)
            ctx.fillStyle = '#48bb78';
            ctx.fillRect(endPoint.col * cellSize, endPoint.row * cellSize, cellSize, cellSize);
            // Draw a small white cross within the end cell to indicate the goal
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(endPoint.col * cellSize + cellSize * 0.2, endPoint.row * cellSize + cellSize * 0.8);
            ctx.lineTo(endPoint.col * cellSize + cellSize * 0.8, endPoint.row * cellSize + cellSize * 0.2);
            ctx.moveTo(endPoint.col * cellSize + cellSize * 0.2, endPoint.row * cellSize + cellSize * 0.2);
            ctx.lineTo(endPoint.col * cellSize + cellSize * 0.8, endPoint.row * cellSize + cellSize * 0.8);
            ctx.stroke();

            drawBall(); // Draw the ball last, so it appears on top of the maze
        }

        /**
         * Draws the red ball at its current calculated position.
         */
        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2); // Draw a circle
            ctx.fillStyle = '#e53e3e'; // Red color for the ball
            ctx.fill();
        }

        /**
         * Checks if a specific point (e.g., part of the ball) is inside a maze wall.
         * @param {number} x - X coordinate of the point to check.
         * @param {number} y - Y coordinate of the point to check.
         * @returns {boolean} True if the point is within a wall cell, false otherwise.
         */
        function isWallAt(x, y) {
            // Treat points outside canvas boundaries as walls
            if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
                return true;
            }
            const col = Math.floor(x / cellSize); // Get column index
            const row = Math.floor(y / cellSize); // Get row index
            // Check if the corresponding cell in the maze array is a wall (value 1)
            return maze[row] && maze[row][col] === 1;
        }

        /**
         * The main game animation loop.
         * Updates the ball's position based on physics and input, handles collisions,
         * redraws the game, and checks for win conditions.
         */
        function animate() {
            if (gameWon) {
                cancelAnimationFrame(animationFrameId); // Stop the animation if game is won
                return;
            }

            // Calculate the vector from the ball's current position to the target position
            const dx_target = targetX - ball.x;
            const dy_target = targetY - ball.y;
            const distance_to_target = Math.sqrt(dx_target * dx_target + dy_target * dy_target);

            // Apply force (acceleration) towards the target if the pointer is down
            // and the ball is not extremely close to the target (to prevent jitter)
            if (distance_to_target > 2 && (mouse.isDown || touch.isDown)) {
                ball.vx += (dx_target / distance_to_target) * ball.speed;
                ball.vy += (dy_target / distance_to_target) * ball.speed;
            }

            // Apply damping (friction) to gradually slow down the ball
            ball.vx *= ball.damping;
            ball.vy *= ball.damping;

            // Limit the maximum speed of the ball
            const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            const maxSpeed = cellSize * 0.3; // Max speed is proportional to cell size for consistent feel
            if (currentSpeed > maxSpeed) {
                ball.vx = (ball.vx / currentSpeed) * maxSpeed;
                ball.vy = (ball.vy / currentSpeed) * maxSpeed;
            }

            let newBallX = ball.x + ball.vx; // Predicted next X position
            let newBallY = ball.y + ball.vy; // Predicted next Y position

            let collidedX = false;
            let collidedY = false;

            // Collision detection and response for horizontal (X-axis) movement
            // Check multiple points around the ball's circumference at its predicted new X position
            const checkPointsX = [
                { x: newBallX - ball.radius, y: ball.y + 1 },    // Left, slightly below center
                { x: newBallX + ball.radius, y: ball.y + 1 },   // Right, slightly below center
                { x: newBallX - ball.radius, y: ball.y - 1 }, // Left, slightly above center
                { x: newBallX + ball.radius, y: ball.y - 1 },// Right, slightly above center
                { x: newBallX - ball.radius, y: ball.y },         // Left center
                { x: newBallX + ball.radius, y: ball.y }         // Right center
            ];
            for (const p of checkPointsX) {
                if (isWallAt(p.x, p.y)) {
                    collidedX = true;
                    break; // Found a collision, no need to check further points for X
                }
            }

            if (collidedX) {
                ball.vx = 0; // Stop horizontal movement immediately
                // Adjust ball's X position to "snap" it out of the wall, preventing sticking
                const currentCellCol = Math.floor(ball.x / cellSize);
                if (newBallX > ball.x) { // Moving right, hit wall on right
                    ball.x = currentCellCol * cellSize + cellSize - ball.radius - 1;
                } else { // Moving left, hit wall on left
                    ball.x = currentCellCol * cellSize + ball.radius + 1;
                }
            } else {
                ball.x = newBallX; // If no collision, update ball's X position
            }

            // Collision detection and response for vertical (Y-axis) movement
            // Check multiple points around the ball's circumference at its predicted new Y position
            const checkPointsY = [
                { x: ball.x + 1, y: newBallY - ball.radius },    // Top, slightly right of center
                { x: ball.x + 1, y: newBallY + ball.radius },   // Bottom, slightly right of center
                { x: ball.x - 1, y: newBallY - ball.radius }, // Top, slightly left of center
                { x: ball.x - 1, y: newBallY + ball.radius },// Bottom, slightly left of center
                { x: ball.x, y: newBallY - ball.radius },             // Top center
                { x: ball.x, y: newBallY + ball.radius }           // Bottom center
            ];
            for (const p of checkPointsY) {
                if (isWallAt(p.x, p.y)) {
                    collidedY = true;
                    break; // Found a collision, no need to check further points for Y
                }
            }

            if (collidedY) {
                ball.vy = 0; // Stop vertical movement immediately
                // Adjust ball's Y position to "snap" it out of the wall
                const currentCellRow = Math.floor(ball.y / cellSize);
                if (newBallY > ball.y) { // Moving down, hit wall on bottom
                    ball.y = currentCellRow * cellSize + cellSize - ball.radius - 1;
                } else { // Moving up, hit wall on top
                    ball.y = currentCellRow * cellSize + ball.radius + 1;
                }
            } else {
                ball.y = newBallY; // If no collision, update ball's Y position
            }

            // Clamp ball position within canvas boundaries to ensure it never leaves the play area
            ball.x = Math.max(ball.radius, Math.min(ball.x, canvas.width - ball.radius));
            ball.y = Math.max(ball.radius, Math.min(ball.y, canvas.height - ball.radius));

            drawMaze();          // Redraw the entire game state with updated ball position
            checkWinCondition(); // Check if the ball has reached the end point
            updateDebugInfo();   // Update the debug display with current game states

            // Request the next animation frame, creating a continuous loop
            animationFrameId = requestAnimationFrame(animate);
        }

        /**
         * Sets the target coordinates for the ball based on the user's mouse or touch input.
         * @param {number} clientX - The X coordinate of the input event relative to the viewport.
         * @param {number} clientY - The Y coordinate of the input event relative to the viewport.
         */
        function setTargetPosition(clientX, clientY) {
            if (gameWon) return; // Ignore input if the game is already won

            // Get the canvas's size and position relative to the viewport
            const rect = canvas.getBoundingClientRect();
            // Calculate target coordinates relative to the canvas
            targetX = clientX - rect.left;
            targetY = clientY - rect.top;

            // Clamp target coordinates to stay within canvas bounds
            targetX = Math.max(0, Math.min(targetX, canvas.width));
            targetY = Math.max(0, Math.min(targetY, canvas.height));
        }

        /**
         * Checks if the ball has reached the end point of the maze.
         */
        function checkWinCondition() {
            // Get the grid cell coordinates of the ball
            const ballGridCol = Math.floor(ball.x / cellSize);
            const ballGridRow = Math.floor(ball.y / cellSize);

            // Check if ball is in the same grid cell as the end point and game is not already won
            if (ballGridCol === endPoint.col && ballGridRow === endPoint.row && !gameWon) {
                gameWon = true; // Set game won state
                messageBox.textContent = "Congratulations! You won the maze!"; // Update message for the user
                ctx.fillStyle = 'rgba(72, 187, 120, 0.5)'; // Apply a semi-transparent green overlay for visual feedback
                ctx.fillRect(0, 0, canvas.width, canvas.height); // Draw the overlay
                cancelAnimationFrame(animationFrameId); // Stop the animation loop as the game is over
            }
        }

        // --- Event Listeners for Mouse and Touch Interactions ---

        // Mouse events (for desktop interaction)
        canvas.addEventListener('mousedown', (e) => {
            mouse.isDown = true;
            setTargetPosition(e.clientX, e.clientY);
            updateDebugInfo(); // Update debug info to reflect mouse state
        });

        canvas.addEventListener('mousemove', (e) => {
            if (mouse.isDown && gameStarted && !gameWon) {
                setTargetPosition(e.clientX, e.clientY);
            }
        });

        canvas.addEventListener('mouseup', () => {
            mouse.isDown = false;
            updateDebugInfo(); // Update debug info to reflect mouse state
        });

        canvas.addEventListener('mouseleave', () => {
            mouse.isDown = false;
            updateDebugInfo(); // Update debug info if mouse leaves canvas area
        });

        // Touch events (for mobile interaction)
        // `passive: false` is crucial here to allow `e.preventDefault()` to stop default browser behaviors (like scrolling)
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent default browser touch actions
            touch.isDown = true;
            const touch = e.touches[0]; // Get the first touch point
            setTargetPosition(touch.clientX, touch.clientY);
            updateDebugInfo(); // Update debug info to reflect touch state
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent default browser touch actions
            if (touch.isDown && gameStarted && !gameWon) {
                const touch = e.touches[0]; // Get the first touch point
                setTargetPosition(touch.clientX, e.clientY); // Fixed this line: changed touch.clientX to touch.clientY
            }
        }, { passive: false });

        canvas.addEventListener('touchend', () => {
            touch.isDown = false;
            updateDebugInfo(); // Update debug info to reflect touch state
        });

        canvas.addEventListener('touchcancel', () => {
            touch.isDown = false;
            updateDebugInfo(); // Update debug info if touch interaction is cancelled
        });

        // Reset button functionality
        resetButton.addEventListener('click', initializeGame);

        // Handle window resize to ensure the canvas scales correctly on different screen sizes
        window.addEventListener('resize', initializeGame);

        // Initial game setup when the entire window content (including images, etc.) has loaded
        window.onload = initializeGame;
    </script>
</body>
</html>
"Replace content with clean maze game HTML"
