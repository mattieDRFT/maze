<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Runner</title>
    <!-- Google Fonts - Inter for clean typography -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js CDN for 3D background animation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Base styles for the body to provide a clean white background and center the game */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #000000; /* Dark background for galaxy theme */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Full viewport height */
            margin: 0; /* Remove default body margin */
            overflow: hidden; /* Prevent body scrolling, important for touch interactions */
            position: relative; /* Needed for z-index positioning of canvases */
        }

        /* Styling for the 3D background canvas */
        #backgroundCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0; /* Ensures it's behind the maze canvas */
            display: block;
        }

        /* Styling for the main game container */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center; /* Center items horizontally */
            background-color: transparent; /* Transparent background to show galaxy */
            padding: 0; /* Remove padding for a cleaner look */
            border-radius: 0; /* Remove rounded corners */
            box-shadow: none; /* Remove shadows */
            max-width: 90%; /* Max width for responsiveness on larger screens */
            width: fit-content; /* Adjust width to content */
            position: relative; /* Needed for z-index of maze canvas */
            z-index: 1; /* Ensures it's above the background canvas */
        }

        /* Styling for the game canvas itself (maze) */
        canvas {
            background-color: rgba(237, 242, 247, 0.85); /* Slightly transparent white for maze paths */
            border: 4px solid #4a5568; /* Dark border around the maze */
            border-radius: 0.5rem; /* Rounded corners for the canvas */
            touch-action: none; /* Prevents default mobile browser gestures */
            display: block; /* Removes extra space below canvas */
            max-width: 100%; /* Ensures canvas scales down on small screens */
            height: auto; /* Maintains aspect ratio when scaling */
        }
    </style>
</head>
<body>
    <canvas id="backgroundCanvas"></canvas> <!-- 3D background canvas -->
    <div class="game-container">
        <canvas id="mazeCanvas"></canvas> <!-- 2D maze game canvas -->
    </div>

    <script>
        // --- Maze Game Logic ---
        const mazeCanvas = document.getElementById('mazeCanvas');
        const ctx = mazeCanvas.getContext('2d');

        // Mouse and touch state variables
        let mouse = { x: 0, y: 0, isDown: false };
        let touch = { x: 0, y: 0, isDown: false };

        // NEW SOLVABLE Maze Configuration (1 for wall, 0 for path)
        // This maze is designed to be solvable and challenging.
        const maze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1,1,1,1,0,1],
            [1,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,1,0,1],
            [1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,1,1,0,1,0,1],
            [1,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,1,0,1],
            [1,0,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,1,0,1,0,1,0,1],
            [1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1],
            [1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1],
            [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1],
            [1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
            [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1],
            [1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        let cellSize;
        // Ball physics parameters adjusted for faster movement
        let ball = { x: 0, y: 0, radius: 0, vx: 0, vy: 0, speed: 0.9, damping: 0.8 }; /* Adjusted for faster ball */
        let targetX = 0;
        let targetY = 0;
        let gameStarted = false;
        let gameWon = false;
        let animationFrameId; // Stores the ID from requestAnimationFrame for cancellation

        // Start and End points (in maze grid coordinates)
        const startPoint = { row: 1, col: 1 };
        const endPoint = { row: maze.length - 2, col: maze[0].length - 2 }; // Second to last row, second to last column

        /**
         * Initializes or resets the game state.
         * Calculates cell size based on screen, resets ball position, and starts animation.
         */
        function initializeGame() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            const maxCanvasWidth = window.innerWidth * 0.9;
            const maxCanvasHeight = window.innerHeight * 0.8;

            const rows = maze.length;
            const cols = maze[0].length;

            // Set cellSize to a reasonable value that balances size and difficulty with the new maze layout.
            // This ensures the maze is larger and solvable, but still provides a challenge.
            cellSize = Math.min(Math.floor(maxCanvasWidth / cols), Math.floor(maxCanvasHeight / rows), 20); // Balanced size

            mazeCanvas.width = cols * cellSize;
            mazeCanvas.height = rows * cellSize;

            ball.radius = cellSize * 0.4;
            ball.x = startPoint.col * cellSize + cellSize / 2;
            ball.y = startPoint.row * cellSize + cellSize / 2;
            ball.vx = 0;
            ball.vy = 0;

            targetX = ball.x;
            targetY = ball.y;

            gameStarted = true;
            gameWon = false;
            drawMaze();
            animate();
        }

        /**
         * Draws the maze walls, start point, end point, and the ball on the canvas.
         */
        function drawMaze() {
            ctx.clearRect(0, 0, mazeCanvas.width, mazeCanvas.height);

            // Iterate through the maze array to draw walls
            for (let row = 0; row < maze.length; row++) {
                for (let col = 0; col < maze[row].length; col++) {
                    if (maze[row][col] === 1) { // If cell contains a wall
                        ctx.fillStyle = '#4a5568'; /* Wall color (dark grey) to define the white maze path */
                        ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                    }
                }
            }

            // Draw start point (subtle white fill with black border)
            ctx.fillStyle = '#ffffff'; // White fill
            ctx.fillRect(startPoint.col * cellSize, startPoint.row * cellSize, cellSize, cellSize);
            ctx.strokeStyle = '#000000'; // Black border
            ctx.lineWidth = 1;
            ctx.strokeRect(startPoint.col * cellSize, startPoint.row * cellSize, cellSize, cellSize);
            // Draw a small black circle in the start cell
            ctx.beginPath();
            ctx.arc(startPoint.col * cellSize + cellSize / 2, startPoint.row * cellSize + cellSize / 2, ball.radius / 2, 0, Math.PI * 2);
            ctx.fillStyle = '#000000'; // Black circle
            ctx.fill();

            // Draw end point (subtle white fill with black border)
            ctx.fillStyle = '#ffffff'; // White fill
            ctx.fillRect(endPoint.col * cellSize, endPoint.row * cellSize, cellSize, cellSize);
            ctx.strokeStyle = '#000000'; // Black border
            ctx.lineWidth = 1;
            ctx.strokeRect(endPoint.col * cellSize, endPoint.row * cellSize, cellSize, cellSize);
            // Draw a small black cross in the end cell
            ctx.strokeStyle = '#000000'; // Black cross
            ctx.lineWidth = 2; // Slightly thicker cross for visibility
            ctx.beginPath();
            ctx.moveTo(endPoint.col * cellSize + cellSize * 0.2, endPoint.row * cellSize + cellSize * 0.8);
            ctx.lineTo(endPoint.col * cellSize + cellSize * 0.8, endPoint.row * cellSize + cellSize * 0.2);
            ctx.moveTo(endPoint.col * cellSize + cellSize * 0.2, endPoint.row * cellSize + cellSize * 0.2);
            ctx.lineTo(endPoint.col * cellSize + cellSize * 0.8, endPoint.row * cellSize + cellSize * 0.8);
            ctx.stroke();

            drawBall();
        }

        /**
         * Draws the red ball at its current calculated position.
         */
        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = '#e53e3e';
            ctx.fill();
        }

        /**
         * Checks if a specific point (e.g., part of the ball) is inside a maze wall.
         */
        function isWallAt(x, y) {
            if (x < 0 || x >= mazeCanvas.width || y < 0 || y >= mazeCanvas.height) {
                return true;
            }
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);
            return maze[row] && maze[row][col] === 1;
        }

        /**
         * The main game animation loop.
         * Updates the ball's position based on physics and input, handles collisions,
         * redraws the game, and checks for win conditions.
         */
        function animate() {
            if (gameWon) {
                cancelAnimationFrame(animationFrameId);
                return;
            }

            const dx_target = targetX - ball.x;
            const dy_target = targetY - ball.y;
            const distance_to_target = Math.sqrt(dx_target * dx_target + dy_target * dy_target);

            if (distance_to_target > 2 && (mouse.isDown || touch.isDown)) {
                ball.vx += (dx_target / distance_to_target) * ball.speed;
                ball.vy += (dy_target / distance_to_target) * ball.speed;
            }

            ball.vx *= ball.damping;
            ball.vy *= ball.damping;

            const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            const maxSpeed = cellSize * 0.5; /* Adjusted max speed for faster ball */
            if (currentSpeed > maxSpeed) {
                ball.vx = (ball.vx / currentSpeed) * maxSpeed;
                ball.vy = (ball.vy / currentSpeed) * maxSpeed;
            }

            let newBallX = ball.x + ball.vx;
            let newBallY = ball.y + ball.vy;

            let collidedX = false;
            let collidedY = false;

            const checkPointsX = [
                { x: newBallX - ball.radius, y: ball.y + 1 },
                { x: newBallX + ball.radius, y: ball.y + 1 },
                { x: newBallX - ball.radius, y: ball.y - 1 },
                { x: newBallX + ball.radius, y: ball.y - 1 },
                { x: newBallX - ball.radius, y: ball.y },
                { x: newBallX + ball.radius, y: ball.y }
            ];
            for (const p of checkPointsX) {
                if (isWallAt(p.x, p.y)) {
                    collidedX = true;
                    break;
                }
            }

            if (collidedX) {
                ball.vx = 0;
                const currentCellCol = Math.floor(ball.x / cellSize);
                if (newBallX > ball.x) {
                    ball.x = currentCellCol * cellSize + cellSize - ball.radius - 1;
                } else {
                    ball.x = currentCellCol * cellSize + ball.radius + 1;
                }
            } else {
                ball.x = newBallX;
            }

            const checkPointsY = [
                { x: ball.x + 1, y: newBallY - ball.radius },
                { x: ball.x + 1, y: newBallY + ball.radius },
                { x: ball.x - 1, y: newBallY - ball.radius },
                { x: ball.x - 1, y: newBallY + ball.radius },
                { x: ball.x, y: newBallY - ball.radius },
                { x: ball.x, y: newBallY + ball.radius }
            ];
            for (const p of checkPointsY) {
                if (isWallAt(p.x, p.y)) {
                    collidedY = true;
                    break;
                }
            }

            if (collidedY) {
                ball.vy = 0;
                const currentCellRow = Math.floor(ball.y / cellSize);
                if (newBallY > ball.y) {
                    ball.y = currentCellRow * cellSize + cellSize - ball.radius - 1;
                } else {
                    ball.y = currentCellRow * cellSize + ball.radius + 1;
                }
            } else {
                ball.y = newBallY;
            }

            ball.x = Math.max(ball.radius, Math.min(ball.x, mazeCanvas.width - ball.radius));
            ball.y = Math.max(ball.radius, Math.min(ball.y, mazeCanvas.height - ball.radius));

            drawMaze();
            checkWinCondition();

            animationFrameId = requestAnimationFrame(animate);
        }

        /**
         * Checks if the ball has reached the end point of the maze.
         */
        function checkWinCondition() {
            const ballGridCol = Math.floor(ball.x / cellSize);
            const ballGridRow = Math.floor(ball.y / cellSize);

            if (ballGridCol === endPoint.col && ballGridRow === endPoint.row && !gameWon) {
                gameWon = true;
                ctx.fillStyle = 'rgba(72, 187, 120, 0.5)';
                ctx.fillRect(0, 0, mazeCanvas.width, mazeCanvas.height);
                cancelAnimationFrame(animationFrameId);
            }
        }

        // --- Event Listeners for Mouse and Touch Interactions ---
        mazeCanvas.addEventListener('mousedown', (e) => {
            mouse.isDown = true;
            setTargetPosition(e.clientX, e.clientY);
        });

        mazeCanvas.addEventListener('mousemove', (e) => {
            if (mouse.isDown && gameStarted && !gameWon) {
                setTargetPosition(e.clientX, e.clientY);
            }
        });

        mazeCanvas.addEventListener('mouseup', () => {
            mouse.isDown = false;
        });

        mazeCanvas.addEventListener('mouseleave', () => {
            mouse.isDown = false;
        });

        mazeCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touch.isDown = true;
            const touch = e.touches[0];
            setTargetPosition(touch.clientX, touch.clientY);
        }, { passive: false });

        mazeCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (touch.isDown && gameStarted && !gameWon) {
                const touch = e.touches[0];
                setTargetPosition(touch.clientX, touch.clientY);
            }
        }, { passive: false });

        mazeCanvas.addEventListener('touchend', () => {
            touch.isDown = false;
        });

        mazeCanvas.addEventListener('touchcancel', () => {
            touch.isDown = false;
        });

        // --- Three.js Galaxy Background Logic ---
        const backgroundCanvas = document.getElementById('backgroundCanvas');
        let scene, camera, renderer, stars;
        let starGeo;

        function initThreeJS() {
            // Set dimensions for the background canvas
            backgroundCanvas.width = window.innerWidth;
            backgroundCanvas.height = window.innerHeight;

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = 1; // Pull camera back slightly
            camera.rotation.x = Math.PI / 2; // Look down into the starfield

            renderer = new THREE.WebGLRenderer({ canvas: backgroundCanvas, alpha: true }); // Alpha true for transparency
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Create Starfield
            starGeo = new THREE.BufferGeometry();
            const positions = [];
            const velocities = []; // Store velocity for each star

            for (let i = 0; i < 6000; i++) { // More stars for a denser field
                positions.push(Math.random() * 600 - 300); // X
                positions.push(Math.random() * 600 - 300); // Y
                positions.push(Math.random() * 600 - 300); // Z
                velocities.push(0); // Initial velocity for Z-axis movement
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            starGeo.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 1)); // Single component for Z velocity

            const starMaterial = new THREE.PointsMaterial({
                color: 0xaaaaaa, // Greyish white stars
                size: 0.7, // Smaller size for more granular stars
                map: createStarTexture(), // Use a small, circular texture for stars
                transparent: true,
                blending: THREE.AdditiveBlending // For brighter, glowing stars
            });

            stars = new THREE.Points(starGeo, starMaterial);
            scene.add(stars);

            window.addEventListener('resize', onWindowResizeThreeJS, false); // Handle resize for 3D canvas
        }

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(
                canvas.width / 2,
                canvas.height / 2,
                0,
                canvas.width / 2,
                canvas.height / 2,
                canvas.width / 2
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.5)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);
            return new THREE.CanvasTexture(canvas);
        }


        function animateThreeJS() {
            // Stars movement
            starGeo.attributes.position.array.forEach((_, i) => {
                if (i % 3 === 2) { // Z-coordinate
                    starGeo.attributes.position.array[i] += starGeo.attributes.velocity.array[i / 3];
                    starGeo.attributes.velocity.array[i / 3] += 0.0005; // Accelerate stars slightly

                    // Reset star position if it moves past the camera
                    if (starGeo.attributes.position.array[i] > 200) { // If star moves too close
                        starGeo.attributes.position.array[i] = -300; // Reset far back
                        starGeo.attributes.velocity.array[i / 3] = 0; // Reset velocity
                    }
                }
            });
            starGeo.attributes.position.needsUpdate = true; // Tell Three.js to update positions

            // Rotate starfield slightly for dynamic feel
            stars.rotation.z += 0.0005;

            renderer.render(scene, camera);
            requestAnimationFrame(animateThreeJS);
        }

        function onWindowResizeThreeJS() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            backgroundCanvas.width = window.innerWidth;
            backgroundCanvas.height = window.innerHeight;
        }

        // Initialize games when window loads
        window.onload = function() {
            initializeGame(); // Initialize the 2D maze game
            initThreeJS();    // Initialize the 3D galaxy background
            animateThreeJS(); // Start the 3D animation loop
        };

        // Handle window resize for both canvases
        window.addEventListener('resize', () => {
            initializeGame(); // Re-initialize maze for new size
            onWindowResizeThreeJS(); // Adjust 3D background size
        });
    </script>
</body>
</html>
